2.how many digit store in memory address
#include<stdio.h>
int main()
{

    int x=42;
    int*ptr=&x;
    printf("address stored in ptr:%p\n",ptr);
    printf("address of ptr itself:%p\n,(void*)&ptr");
    return 0;
}
3.selection sort with dynamic memory allocation
#include <stdio.h>
#include <stdlib.h>

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}

int main() {
    int n;
    printf("Enter number of elements (max 100): ");
    scanf("%d", &n);

    int arr[100];  

    printf("Enter %d integers:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    selectionSort(arr, n);

    printf("Sorted array:\n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    printf("\nMAC Addresses of this system:\n");
    system("getmac");

    return 0;
}
4.selection of sort without dynamic memory allocation
#include <stdio.h>
#include <stdlib.h>

int main() {
    int rows, cols;
    printf("Enter number of rows: ");
    scanf("%d", &rows);
    printf("Enter number of columns: ");
    scanf("%d", &cols);
    int **arr = (int **)malloc(rows * sizeof(int *));
    for (int i = 0; i < rows; i++) {
        arr[i] = (int *)malloc(cols * sizeof(int));
    }
    printf("Enter elements:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &arr[i][j]);
        }
    }
    printf("Matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
    system("getmac");
    for (int i = 0; i < rows; i++) {
        free(arr[i]);
    }
    free(arr);

    return 0;
}
5.declaration of two dimenstional array using dynamic memory allocation
#include <stdio.h>
#include <stdlib.h>

int main() {
    int rows, cols;
    printf("Enter number of rows: ");
    scanf("%d", &rows);
    printf("Enter number of columns: ");
    scanf("%d", &cols);
    int **arr = (int **)malloc(rows * sizeof(int *));
    for (int i = 0; i < rows; i++) {
        arr[i] = (int *)malloc(cols * sizeof(int));
    }
    printf("Enter elements:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &arr[i][j]);
        }
    }
   printf("Matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
  system("getmac");
    for (int i = 0; i < rows; i++) {
        free(arr[i]);
    }
    free(arr);
    return 0;
}
6.pattern matching (general way)
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void patternMatching(char text[], char pattern[]) {
    int n = strlen(text);
    int m = strlen(pattern);
    for (int i = 0; i <= n - m; i++) {
        int j;
        for (j = 0; j < m; j++) {
            if (text[i + j] != pattern[j]) {
                break;
            }
        }
        if (j == m) {
            printf("Pattern found at index %d\n", i);
        }
    }
}
int main() {
    char text[100], pattern[50];
    printf("Enter the text: ");
    scanf("%s", text);
    printf("Enter the pattern: ");
    scanf("%s", pattern);
    patternMatching(text, pattern);
    system("getmac");
    return 0;
}
7.self referential structure
#include <stdio.h>
#include <stdlib.h>
struct Node {
    int data;
    struct Node *next;
};
struct Node* create_node(int value) {
    struct Node *n = (struct Node*)malloc(sizeof(struct Node));
    if (!n) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    n->data = value;
    n->next = NULL;
    return n;
}
void push_front(struct Node **head, int value) {
    struct Node *n = create_node(value);
    n->next = *head;
    *head = n;
}
void print_list(struct Node *head) {
    printf("Linked List: ");
    while (head) {
        printf("%d", head->data);
        if (head->next) printf(" -> ");
        head = head->next;
    }
    printf(" -> NULL\n");
}
void free_list(struct Node *head) {
    while (head) {
        struct Node *temp = head;
        head = head->next;
        free(temp);
    }
}
int main() {
        printf("Executing system(\"getmac\")...\n");
    system("getmac");
    struct Node *head = NULL;
    push_front(&head, 10);
    push_front(&head, 20);
    push_front(&head, 30);
    print_list(head);   
free_list(head);
    return 0;
}
8.pre increment pos increment 
#include <stdio.h>
#include <stdlib.h>
int main() {
        printf("Executing system(\"getmac\")...\n");
    system("getmac");
    int a = 5, b = 5;
    printf("\n--- Pre-Increment Demo ---\n");
    printf("Initial value of a = %d\n", a);
    printf("Value after ++a = %d\n", ++a);
    printf("Final value of a = %d\n", a);
    printf("\n--- Post-Increment Demo ---\n");
    printf("Initial value of b = %d\n", b);
    printf("Value after b++ = %d\n", b++); 
    printf("Final value of b = %d\n", b);
    return 0;
}
9.post decrement and pre decrement
#include <stdio.h>
#include <stdlib.h>
int main() {
        printf("Executing system(\"getmac\")...\n");
    system("getmac");
    int a = 4;
    printf("\n--- Post-Increment Demo ---\n");
    printf("Initial value of a = %d\n", a);
    printf("Value after a++ = %d\n", a++); 
    printf("Final value of a = %d\n", a);
      int b = 4;
    printf("\n--- Post-Decrement Demo ---\n");
    printf("Initial value of b = %d\n", b);
    printf("Value after b-- = %d\n", b--);
    printf("Final value of b = %d\n", b);
    return 0;
}
10.regular queue
#include <stdio.h>
#include <stdlib.h>
#define MAX 5 
struct Queue {
    int arr[MAX];
    int front;
    int rear;
};
void init(struct Queue *q) {
    q->front = -1;
    q->rear = -1;
}
int isFull(struct Queue *q) {
    return (q->rear == MAX - 1);
}
int isEmpty(struct Queue *q) {
    return (q->front == -1 || q->front > q->rear);
}
void enqueue(struct Queue *q, int value) {
    if (isFull(q)) {
        printf("Queue Overflow! Cannot insert %d\n", value);
        return;
    }
    if (q->front == -1) q->front = 0;
    q->arr[++q->rear] = value;
    printf("Enqueued: %d\n", value);
}

int dequeue(struct Queue *q) {
    if (isEmpty(q)) {
        printf("Queue Underflow! Cannot dequeue\n");
        return -1;
    }
    int val = q->arr[q->front++];
    printf("Dequeued: %d\n", val);
    return val;
}
void display(struct Queue *q) {
    if (isEmpty(q)) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue elements: ");
    for (int i = q->front; i <= q->rear; i++) {
        printf("%d ", q->arr[i]);
    }
    printf("\n");
}
int main() {
       printf("Executing system(\"getmac\")...\n");
    system("getmac");
    struct Queue q;
    init(&q);
    enqueue(&q, 10);
    enqueue(&q, 20);
    enqueue(&q, 30);
    display(&q);
    dequeue(&q);
    display(&q);
    enqueue(&q, 40);
    enqueue(&q, 50);
    enqueue(&q, 60); 
    display(&q);
    return 0;
}
11.operation of linked list(traversal,insertion,deletion)
#include <stdio.h>
#include <stdlib.h>
struct Node {
    int data;
    struct Node *next;
};
struct Node* create_node(int value) {
    struct Node *n = (struct Node*)malloc(sizeof(struct Node));
    if (!n) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    n->data = value;
    n->next = NULL;
    return n;
}
void insert_front(struct Node **head, int value) {
    struct Node *n = create_node(value);
    n->next = *head;
    *head = n;
}
void insert_end(struct Node **head, int value) {
    struct Node *n = create_node(value);
    if (*head == NULL) {
        *head = n;
        return;
    }
    struct Node *temp = *head;
    while (temp->next) {
        temp = temp->next;
    }
    temp->next = n;
}
void delete_node(struct Node **head, int value) {
    if (*head == NULL) {
        printf("List is empty, cannot delete %d\n", value);
        return;
    }
    struct Node *temp = *head, *prev = NULL;
      if (temp != NULL && temp->data == value) {
        *head = temp->next;
        free(temp);
        printf("Deleted: %d\n", value);
        return;
    }
    while (temp != NULL && temp->data != value) {
        prev = temp;
        temp = temp->next;
    }
    if (temp == NULL) {
        printf("Value %d not found in list\n", value);
        return;
    }
       prev->next = temp->next;
    free(temp);
    printf("Deleted: %d\n", value);
}
void traverse(struct Node *head) {
    printf("Linked List: ");
    while (head) {
        printf("%d", head->data);
        if (head->next) printf(" -> ");
        head = head->next;
    }
    printf(" -> NULL\n");
}

void free_list(struct Node *head) {
    while (head) {
        struct Node *temp = head;
        head = head->next;
        free(temp);
    }
}

int main() {
       printf("Executing system(\"getmac\")...\n");
    system("getmac");
    struct Node *head = NULL;
    insert_front(&head, 10);
    insert_front(&head, 20);
    insert_end(&head, 30);
    insert_end(&head, 40);
    traverse(head);  
    delete_node(&head, 10);
    traverse(head);  
    delete_node(&head, 40);
    traverse(head); 
    delete_node(&head, 99); 
    free_list(head);
    return 0;
}
12.linked list using stacks
#include <stdio.h>
#include <stdlib.h>
struct Node {
    int data;
    struct Node *next;
};
struct Node* create_node(int value) {
    struct Node *n = (struct Node*)malloc(sizeof(struct Node));
    if (!n) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    n->data = value;
    n->next = NULL;
    return n;
}
void push(struct Node **top, int value) {
    struct Node *n = create_node(value);
    n->next = *top;
    *top = n;
    printf("Pushed: %d\n", value);
}
int pop(struct Node **top) {
    if (*top == NULL) {
        printf("Stack Underflow! Cannot pop\n");
        return -1;
    }
    struct Node *temp = *top;
    int val = temp->data;
    *top = temp->next;
    free(temp);
    printf("Popped: %d\n", val);
    return val;
}
int peek(struct Node *top) {
    if (top == NULL) {
        printf("Stack is empty\n");
        return -1;
    }
    return top->data;
}
void display(struct Node *top) {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    printf("Stack elements (top to bottom): ");
    while (top) {
        printf("%d ", top->data);
        top = top->next;
    }
    printf("\n");
}
void free_stack(struct Node *top) {
    while (top) {
        struct Node *temp = top;
        top = top->next;
        free(temp);
    }
}
int main() {
        printf("Executing system(\"getmac\")...\n");
    system("getmac");
    struct Node *stack = NULL;
    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);
    display(stack);  
    printf("Peek: %d\n", peek(stack));
    pop(&stack);
    display(stack);  
    pop(&stack);
    pop(&stack);
    pop(&stack);   
    free_stack(stack);
    return 0;
}
13.linked list using queues
#include <stdio.h>
#include <stdlib.h>
struct Node {
    int data;
    struct Node *next;
};
struct Queue {
    struct Node *front;
    struct Node *rear;
};
void init(struct Queue *q) {
    q->front = q->rear = NULL;
}
void enqueue(struct Queue *q, int value) {
    struct Node *n = (struct Node*)malloc(sizeof(struct Node));
    if (!n) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    n->data = value;
    n->next = NULL;
    if (q->rear == NULL) {
        q->front = q->rear = n;
    } else {
        q->rear->next = n;
        q->rear = n;
    }
    printf("Enqueued: %d\n", value);
}
int dequeue(struct Queue *q) {
    if (q->front == NULL) {
        printf("Queue Underflow! Cannot dequeue\n");
        return -1;
    }
    struct Node *temp = q->front;
    int val = temp->data;
    q->front = q->front->next;
    if (q->front == NULL) {
        q->rear = NULL;
    }
    free(temp);
    printf("Dequeued: %d\n", val);
    return val;
}
void display(struct Queue *q) {
    if (q->front == NULL) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue elements (front to rear): ");
    struct Node *temp = q->front;
    while (temp) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}
void free_queue(struct Queue *q) {
    while (q->front) {
        struct Node *temp = q->front;
        q->front = q->front->next;
        free(temp);
    }
    q->rear = NULL;
}
int main() {
       printf("Executing system(\"getmac\")...\n");
    system("getmac");
    struct Queue q;
    init(&q);
    enqueue(&q, 10);
    enqueue(&q, 20);
    enqueue(&q, 30);
    display(&q); 
    dequeue(&q);
    display(&q);
    enqueue(&q, 40);
    enqueue(&q, 50);
    display(&q);   
    dequeue(&q);
    dequeue(&q);
    display(&q);  
    free_queue(&q);
    return 0;
}
14.time taken for arrays and linked lists during insertion and deletion
#include <stdio.h>
#include <stdlib.h>
struct Node {
    int data;
    struct Node* next;
};
void printList(struct Node* n) {
    while (n != NULL) {
        printf("%d -> ", n->data);
        n = n->next;
    }
    printf("NULL\n");
}
int main() {
      int arr[10] = {10, 20, 30, 40};
    int n = 4;
    int valueToInsert = 5;
    for (int i = n; i > 0; i--) {
        arr[i] = arr[i - 1];
    }
    arr[0] = valueToInsert;
    n++;
    printf("Array after insertion at start: ");
    for(int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    struct Node* head = (struct Node*)malloc(sizeof(struct Node));
    head->data = 10;
    head->next = NULL;
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = 5;
    newNode->next = head; 
    head = newNode;
    printf("Linked List after insertion at start: ");
    printList(head);
    printf("\n--- Fetching System MAC Address ---\n");
    system("getmac");
    return 0;
}
15.sparse matrix
#include <stdio.h>
#include <stdlib.h>
int main() {
        int sparseMatrix[4][5] = {
        {0, 0, 3, 0, 4},
        {0, 0, 5, 7, 0},
        {0, 0, 0, 0, 0},
        {0, 2, 6, 0, 0}
    };

    int size = 0;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 5; j++) {
            if (sparseMatrix[i][j] != 0) {
                size++;
            }
        }
    }
    int compactMatrix[size][3];
    int k = 0;

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 5; j++) {
            if (sparseMatrix[i][j] != 0) {
                compactMatrix[k][0] = i;
                compactMatrix[k][1] = j;
                compactMatrix[k][2] = sparseMatrix[i][j];
                k++;
            }
        }
    }
    printf("Triplet Representation of Sparse Matrix:\n");
    printf("Row\tCol\tValue\n");
    printf("---\t---\t-----\n");
    for (int i = 0; i < size; i++) {
        printf("%d\t%d\t%d\n", compactMatrix[i][0], compactMatrix[i][1], compactMatrix[i][2]);
    }
    printf("\n--- Fetching System MAC Address ---\n");
    system("getmac");
    return 0;
}
16.polynomial representation
#include <stdio.h>
#include <stdlib.h>
struct Node {
    int coeff;
    int expo;
    struct Node* next;
};
struct Node* createNode(int c, int e) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->coeff = c;
    newNode->expo = e;
    newNode->next = NULL;
    return newNode;
}
void displayPolynomial(struct Node* ptr) {
    while (ptr != NULL) {
        printf("%dx^%d", ptr->coeff, ptr->expo);
        ptr = ptr->next;
        if (ptr != NULL && ptr->coeff >= 0) {
            printf(" + ");
        }
    }
    printf("\n");
}
int main() {
        struct Node* head = createNode(5, 2);
    head->next = createNode(3, 1);
    head->next->next = createNode(2, 0);
    printf("Represented Polynomial: ");
    displayPolynomial(head);
    printf("\n--- System MAC Address ---\n");
    system("getmac");
    return 0;
}
